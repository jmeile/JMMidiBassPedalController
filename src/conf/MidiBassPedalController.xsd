<?xml version="1.0" encoding="UTF-8"?>
<!--
  JMMidiBassPedalController v3.0
  File: src/conf/MidiBassPedalController.xsd
  By:   Josef Meile <jmeile@hotmail.com> @ 28.10.2020
  This project is licensed under the MIT License. Please see the LICENSE.md file
  on the main folder of this code. An online version can be found here:
  https://github.com/jmeile/JMMidiBassPedalController/blob/master/LICENSE.md
  
  This file describes the expected data in the XML configuration file. It will
  also include some validations.
-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning"
           vc:minVersion="1.1"
           targetNamespace="https://www.technosoft.solutions/xsd"
           xmlns="https://www.technosoft.solutions/xsd"
           elementFormDefault="qualified"
>
  <xs:element name="Controller">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Note: this controller will basically transmit four types of messages:
        * Bass pedal messages: it is basically a NOTE ON/OFF message with the
          bass pedal note of a chord.
        * Chord messages: it is a combination of MIDI NOTE ON messages
          describing the chord that will follow the pedal message, ie: after the
          pedal G, the chord G7 may be sent, which has the notes: G, B, D, and
          F.
        * General MIDI messages: for example, a PROGRAM CHANGE message.
        * System Exclusive messages (or SysEx for short): some times you may
          want to send SysEx messages to your connected MIDI keyboard, ie: you
          want to send a rhythm fill in, for this you need to send the SysEx
          that your keyboard has for this purpose.
        Each message excepting the SysEx messages need to use a MIDI channel.
        The following lines allow you to customize this channels for the
        different messages. This is useful since some times you want to hear
        only the bass pedal note of your chords, but use the chord autodetection
        of your keyboard; for this, you can send the pedal notes to a channel
        used by your left voice and the chord notes can be sent to another
        channel that doesn't play voices. If your keyboard plays all MIDI
        channels, then a way of solving this would be to send the chord notes
        with their minimum velocity: 1 (do not choose 0 since it is considered
        as NOTE OFF messages for lots of MIDI devices).
      </xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="CommonAttributes">
          <xs:sequence>
            <xs:element name="Start" type="StartStopNodeType" minOccurs="0"/>
            <xs:element name="Stop" type="StartStopNodeType" minOccurs="0"/>
            <xs:element name="Panic" type="PanicNodeType" minOccurs="0"
                        maxOccurs="1"/>
            <xs:element name="Bank" type="BankType" maxOccurs="119">
              <xs:annotation>
                <xs:documentation xml:lang="en">
                  You can define up to 119 Banks. Here you will define the
                  different combinations for your Bass pedal and chord notes.
                  See the Bank complexType definition to see what's inside.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="Encoding" type="xs:string" default="UTF-8">
            <xs:annotation>
              <xs:documentation xml:lang="en">
                Encoding to use for the bank names, ie: UTF-8, GB2312, etc..
                
                In order to test this in a Windows that is setup on a diffent
                unicode, you will have to use the python ide and not the command
                prompt, which seems to not support other encoding than the setup
                on the user's profile.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="InPort" type="MidiPortType">
            <xs:annotation>
              <xs:documentation xml:lang="en">
                MIDI in port that the controller will use to listen messages. 
                This is a number between 1 and the number of available MIDI in
                ports or a string with the port name (for using wildcards, see
                MidiPortType).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="OutPort" type="MidiPortType">
            <xs:annotation>
              <xs:documentation xml:lang="en">
                MIDI out port that the controller will use to send messages.
                This is a number between 1 and the number of available MIDI in
                ports or a string with the port name (for using wildcards, see
                MidiPortType).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="InChannel" type="MidiChannelType" default="1">
            <xs:annotation>
              <xs:documentation xml:lang="en">
                MIDI channel to which the controller will listen to. Here you
                must use values between 1 and 16. If not given, then 1 will be
                assumed.             
                Please note that the controller will listen only for the
                following messages:
                * NOTE ON / NOTE OFF: are used basically to transmit the bass
                  pedal notes for each chord. They occur when the musician
                  presses and releases a pedal switch.
                * Bank Select messages: here you have to distinguish between two
                  types of Bank Select messages:
                  - The ones sent to the controller: those will use the same
                    MIDI channel that the controller is using for processing
                    messages and they will change Banks for the controller. Here
                    the controller set on: BankSelectController will be used, so
                    this will give you the posibility of setting up maximum 119
                    banks, so, if you send CC + 13 (0DH), then the bank 12 will
                    be selected (please note that the index is zero based, so
                    the first bank would be 0). There will be three special
                    operations:
                    > Sending a CC with a value of 119 (77H) will Send a SysEx
                      back with the bank names. This SysEx has the form:
                      F0 7D 00 (length1.1) (length1.2) ... (bank_name1)
                               (length2.1) (length2.2) ... (bank_name2) ...
                               (checksum) F7
                      where:
                      * 7D is the manufacturer ID, which on this case, we used
                        this ID, which is used for reasearch and not for
                        commercial purposes.
                      * 00 is the operation ID: right now I only have this
                        operation, but if there is a need of defining more
                        SysEx, then this field will be increased.
                      * length is the length of the bank's name. You may see
                        different lengths if the message is longer than 127
                        bytes, ie: for a message with a length of 381, you will
                        have: F0 7D 00 00 00 7F (data) 02 XX YY F0
                        
                        So, here the number 00 will be used to indicate that the
                        length exceeds 127 and that the next byte contains the
                        rest of the length. If again, this length exceeds 127,
                        then a 7F will appear again and so on. For this example
                        we start readings the first bytes:
                        F0 7D 00
                        this tells us that it is a message with the bank names.
                        The next byte is a length, but since it is "00", we get
                        an initial length of 127 and we now that the message is
                        longer than that because of the byte "00". The next one
                        is again a "00", which gives us a length of 127, so, we
                        add it to the previous value and we get: 127 + 127 = 254
                        Since it was "00", we advanced to the next byte, wich is
                        7F (127 in decimal); since it wasn't "00" we now that
                        this is the end of the lengths, so, we add it to the
                        previous value: 254 + 127 = 381. Now we now that the
                        name of the first bank is 381 bytes long, so, we get
                        those bytes and then we can get the length for the next
                        bank name, which on this case would be 02 = 2 bytes
                        length.
                      * bank_name is the name of the bank, which will be coded
                        in 7 bit bytes. To decode it, you will have to use the
                        function: convert_unicode_from_7_bit_bytes from the
                        ByteUtilities.py module.
                      * checksum is a byte to ensure that the data was properly
                        transmited. It will be calculated as follows:
                        checksum = 128 - (sum(DATA) % 128)
                        
                        Note: % is the modulus operator.
                        
                        So, assuming that two messages:
                        - 1A 32                         -> Length: 2  = 02H
                        - 34 54 12 84 52 27 37 82 52 77 -> Length: 10 = 0AH
                        
                        The first part of the message would be:
                        F0 7D 00 02 1A 32 0A 34 54 12 84 52 27 37 82 52 77
                        
                        Now the sum of each value:
                        02+04+1A=20H or 32 in decimal
                        0A+34+54+12+84+52+27+37+82+52+77=323H or 803 in decimal
                        
                        In total: 32 + 803 = 835
                        
                        Note that we consider the lengths also as part of the
                        data. So, then we will have:
                        
                        checksum = 128 - (835 % 128) = 128 - 67 = 61 = 3DH
                        Finally we get:
                        F0 7D 00 02 1A 32 0A 34 54 12 84 52 27 37 82 52 77 3D F7
                    > Sending a CC with a value of 120 (78H) will go to the
                      previous bank.
                    > Sending a CC with a value of 121 (79H) will go to the
                      next bank.
                    > Sending a CC with a value of 122 (7AH) will go to the
                      last bank.
                    > Sending a CC with a value of 123 (7BH) will send a panic
                      command. For this to work, you will need to define the
                      "Panic" node.
                    > Sending a CC with a value of 124 (7CH) will cause the
                      controller software to quit.
                    > Sending a CC with a value of 125 (7DH) will cause the
                      controller software to restart and reread the xml
                      configuration file.
                    > Sending a CC with a value of 126 (7EH) will cause the
                      computer running the controller software to reboot.
                    > Sending a CC with a value of 127 (7FH) will cause the
                      computer running the controller software to shutdown.
                  - The ones forwarded to your connected MIDI devices: they 
                    must use a different channel than the used by the
                    controller and they may be a simple message: controller 32
                    (20H) or a composed message: controller 32 (20H / Bank
                    select LSB) followed by controller 0 (00H / Bank select
                    MSB) depending on the standard used by your keyboard.
                  Other messages or messages sent on different MIDI channels
                  than the one used by the controller, will be fordwarded
                  according to the MidiEcho setting (see above).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="MidiEcho" type="xs:boolean" default="true">
            <xs:annotation>
              <xs:documentation xml:lang="en">
                Whether or not to echo MIDI messages comming from different
                ports than the one that the controller is using for listening
                and processing messages. This is useful if you not only want
                send chords and their bass pedal notes, but also setup your
                other MIDI devices. Possible values: 
                * true or 1: other messages will be forwarded without further
                  post-processing.
                * false or 0: no messages will be fordwarded at all.
                It defaults to "true"
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="BankSelectController" type="ControllerType"
                        default="32">
            <xs:annotation>
              <xs:documentation xml:lang="en">
                MIDI controller that will be used for sending BankSelect
                messages
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="InitialBank" type="BankNumberType"
                        default="1">
            <xs:annotation>
              <xs:documentation xml:lang="en">
                Bank that will be selected when starting the controller software
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="OnBankChange" type="OnBankChangeType"
                        default="StopPlayback">
            <xs:annotation>
              <xs:documentation xml:lang="en">
                This attribute indicates what to do after a BankChange message
                is detected. Possible values:
                - "StopPlayback" (default): triggers NOTE OFF messages for the
                  current pushed pedals.
                - "ContinuePlayback": the current pushed pedals continue playing
                  without any change.
                - "QuickChange": the current pushed pedals will be changed by
                  the respective pedals on the current bank; ie: if the pedal
                  C#2 from bank 1 is being pushed and you changed to bank 2,
                  then NOTE OFF messages for C#2 on bank 1 will be send and then
                  C#2 from bank 2 will trigger the NOTE ON messages; if there is
                  no C#2 on bank 2, then no new pedal will be activated.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="MinVelocityNoteOff" type="xs:boolean" default="true">
            <xs:annotation>
              <xs:documentation xml:lang="en">
                Whether or not to treat NOTE ON messages with a zero velocity as
                NOTE OFF messages. Possible values: 
                * true or 1: NOTE ON messages with zero velocity will be treated
                  as NOTE OFF.
                * false or 0: NOTE ON messages will be allways treated as such
                  no mather its velocity value.
                It defaults to "true".
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="PedalMonophony" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation xml:lang="en">
                Whether or not to enable monophony for pedals. If true, only one
                set of notes will be played at one time; pushing one pedal
                without having released the previous one, will cause to send
                MIDI NOTE OFF messages for the first pedal. It defaults to
                "false"
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  
  <!-- Type declarations -->
  <xs:complexType name="CommonAttributes" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Abstract type for the attribute common to all nodes: Controller, Bank,
        and Pedal.
      </xs:documentation>
    </xs:annotation>
    
    <xs:attribute name="OutBassPedalChannel" type="MidiChannelListType">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          Channel list used by the controller to fordward bass pedal messages.
          If not given, then the value of the parent node will be assumed. If
          there is no parent, then the 1 will be assumed.
          
          Notes:
          * The length of this list determines how many pedal notes will be
          sent, ie: if you enter: "1,14", then two notes will be sent to
          channels 1 and 14.
          * You can't repeat channels on the list; an error will be raised.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    
    <xs:attribute name="OutChordChannel" type="MidiChannelListType">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          Channel list used by the controller to fordward chord messages. If not
          given, then the value of the parent node will be assumed. If there is
          no parent, then the 1 will be assumed.
          
          Notes:
          * The length of this list determines how many chords will be sent, ie:
            if you enter: "1,14", then two chords will be sent to channels 1 and
            14.
          * You can't repeat channels on the list; an error will be raised.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    
    <xs:attribute name="BassPedalVelocity" type="NoteVelocityListType">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          Note velocity list for bass pedal notes. If not given, then the value
          of the parent node will be assumed. If there is no parent, then the
          velocity comming from your foot controller will be assumed.
          
          Notes:
          * The length of this list must be less or equal than the length of
            OutBassPedalChannel; otherwise an error will be raised.
          * If the length of this list is less than the length of
            OutBassPedalChannel, then the velocities of the remaining elements
            will be set according to last value on the list.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="ChordVelocity" type="NoteVelocityListType">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          Note velocity list for chord notes. If not given, then the value of
          the parent node will be assumed. If there is no parent, then the
          velocity comming from your foot controller will be assumed.
          
          Notes:
          * The length of this list must be less or equal than the length of
            OutChordChannel; otherwise an error will be raised.
          * If the length of this list is less than the length of
            OutChordChannel, then the velocities of the remaining elements will
            be set according to the last value of the list.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="BassPedalTranspose" type="TransposeType">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          Note transposition list for bass pedal notes. If not given, then the
          value of the parent node will be used. If there is no parent, then 0
          (zero / no transposition) will be assumed.
          
          Notes:
          * The length of this list must be less or equal than the length of
            OutBassPedalChannel; otherwise an error will be raised.
          * If the length of this list is less than the length of
            OutBassPedalChannel, then the transposition of the remaining
            elements will be set according to the last value of the list.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="ChordTranspose" type="TransposeType">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          Note transposition list for chord notes. If not given, then the
          value of the parent node will be given. If it is there is no parent
          then 0 (zero / no transposition) will be assumed.
          
          Notes:
          * The length of this list must be less or equal than the length of
            OutChordChannel; otherwise an error will be raised.
          * If the length of this list is less than the length of
            OutChordChannel, then the transposition of the remaining elements
            will be set according to the last value of the list.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Octave" type="OctaveType">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          If a note is expressed with a name, ie: C#, then you also need to know
          its octave, which can go from -2 until 8. The only thing you need to
          know is that the maximum note is G8, so, giving a note like: A#8 will
          raise an error. If not given, then the value of the parent will be
          assumed. If the parent isn't set, then 0 will be assumed.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="NoteVelocityListType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for Note velocities. It is a comma separated list containing
        either:
        * a number between 0 and 127
        * a relative velocity beginning with + or - and a number between 0 and
          127. Here the original velocity comming from the pedal controller will
          be added or substracted according to this value. If the resultant
          velocity is greather than 127 or less or equal than 0, then 127 or 1
          will be respectively assumed.
        * or one of the following symbols:
          s:    silence,                        numeric value: 0
          pppp: minimum value,                  numeric value: 10
          ppp:  pianississimo, very very soft,  numeric value: 23
          pp:   pianissimo,    very soft,       numeric value: 36
          p:    piano,         soft,            numeric value: 49
          mp:   mezzo-piano,   moderately soft, numeric value: 62
          mf:   mezzo-forte,   moderately loud, numeric value: 75
          f:    forte,         loud,            numeric value: 88
          ff:   fortissimo,    very loud,       numeric value: 101
          fff:  fortississimo, very very loud,  numeric value: 114
          ffff: maximum value,                  numeric value: 127
        
          Avoid using the minimum value (zero or 's'). This is normally
          interpreted as a NOTE OFF message. If you really need to send it, then
          you could either set it to 1 or use another MIDI channel.
      </xs:documentation>
      <xs:appinfo>
        Those letter equivalences aren't unfortunatelly universal, it depends on
        the MIDI software you are using. Some software will even discard the
        values for: 'pppp' and 'ffff'. If you want to change this values, then
        you will have to modify the following attribute definition and also the
        python code.
      </xs:appinfo>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:appinfo>
          This attribute must be comma separated list containing either a number
          between 0 and 127, or one of the symbols: s, pppp, ppp, pp, p, mp, mf,
          f, ff, fff, or ffff.
        </xs:appinfo>
      </xs:annotation>
      <xs:pattern
        value="(s|pppp|ppp|pp|p|mp|mf|f|ff|fff|ffff|([+-]?([0-9]|[1-9][0-9]|1[0-2][0-7])))(,(s|pppp|ppp|pp|p|mp|mf|f|ff|fff|ffff|([+-]?([0-9]|[1-9][0-9]|1[0-2][0-7]))))*"
      />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="TransposeType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for note transpose. It can be a comma separated list with values
        between -127 and 127. This is the number of semitones that the notes
        will be transposed according to the current octave. If the resulting
        note is lower than 0 (C-2), then it will be transposed to a note on the
        octave -2. If on the contrary, it is higher than 127 (G8), then the
        following cases will be considered:
        * If the note is between C and G, then it will be transposed to a note
          on the octave 8.
        * Otherwise, the note is between G# and B, then it will be transposed to
          a note on the octave 7.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:appinfo>
          This attribute is a comma separated list with values between -127 and
          127
        </xs:appinfo>
      </xs:annotation>
      <xs:pattern
        value="([+-]?([0-9]|[1-9][0-9]|1[0-2][0-7]))(,[+-]?([0-9]|[1-9][0-9]|1[0-2][0-7]))*"
      />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="MidiPortType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for MIDI port. It can be either: a port number starting from 1 and
        it must be less than the number of available ports or a string with the
        full port name, ie: "loopMIDI Port 1" or part of it. In the last case,
        you have to use wildcards, ie: "*GS Wavetable*" will match: "Microsoft
        GS Wavetable Synth 0". You can also match only one character with the
        question mark: '?'. If not given, then by default the last available
        port will be used.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:assertion test="not($value castable as xs:integer) or
                          ($value castable as xs:integer and
                           number($value) > 0)"
      >
        <xs:annotation>
          <xs:documentation xml:lang="en">
            This assertion will validate either that the entered value:
            * is a string (not a number)
            * or is a number higher than 0 (zero)
          </xs:documentation>
        </xs:annotation>
      </xs:assertion>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="MidiChannelType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for MIDI channels. Here you must use values between 1 and 16.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:integer">
      <xs:annotation>
        <xs:appinfo>
          A value between 1 and 16 must be entered.
        </xs:appinfo>
      </xs:annotation>
      <xs:minInclusive value="1"/>
      <xs:maxInclusive value="16"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="MidiChannelListType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for MIDI channel list. Here you must enter a comma separated list
        with values between 1 and 16.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:appinfo>
          A comma separated list with values between 1 and 16 must be entered.
        </xs:appinfo>
      </xs:annotation>
      <xs:pattern value="([1-9]|1[0-6])(,([1-9]|1[0-6]))*"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="ControllerType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for controller numbers. Here you must use values between 0 and 127.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:integer">
      <xs:annotation>
        <xs:appinfo>
          A value between 0 and 127 must be entered.
        </xs:appinfo>
      </xs:annotation>
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="127"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="BankNumberType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for Bank numbers. Here you must use values between 1 and 119.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:integer">
      <xs:annotation>
        <xs:appinfo>
          A value between 1 and 119 must be entered.
        </xs:appinfo>
      </xs:annotation>
      <xs:minInclusive value="1"/>
      <xs:maxInclusive value="119"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="OnBankChangeType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Actions after a BankChange message is detected.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:appinfo>
          Only the following values are possible:
          - "StopPlayback": triggers NOTE OFF messages for the current pushed
            pedals.
          - "ContinuePlayback": the current pushed pedals continue playing
            without any change.
          - "QuickChange": the current pushed pedals will be changed by the
            respective pedals on the current bank; ie: if the pedal C#2 from
            bank 1 is being pushed and you changed to bank 2, then NOTE OFF
            messages for C#2 on bank 1 will be send and then C#2 from bank 2
            will trigger the NOTE ON messages; if there is no C#2 on bank 2,
            then no new pedal will be activated.
        </xs:appinfo>
      </xs:annotation>
      <xs:pattern value="StopPlayback|ContinuePlayback|QuickChange"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="BankType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for the Bank definitions.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CommonAttributes">
        <xs:sequence>
          <xs:element name="Pedal" type="PedalType" maxOccurs="128">
            <xs:annotation>
              <xs:documentation xml:lang="en">
                You can define up to 128 Pedals, which is the maximum number of
                MIDI notes; however take in mind that the number of pedals is in
                deed the number of switches of your pedal board. See the Pedal
                complexType definition to see what's inside.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="Name" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">
              Phrase descripting this bank. If not given, it defaults to "Bank"
              and the number of the current bank.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="StartStopNodeType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for start and stop nodes.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="MessageGroup"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="PedalType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for defining Pedals.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CommonAttributes">
        <xs:sequence>
          <xs:group ref="MessageGroup"/>
        </xs:sequence>
        <xs:attribute name="Note" type="NoteType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">
              It must be either a value between 0 (C-2) and 127 (G8) or one of
              the following symbols: A, A#, B, C, C#, D, D#, E, F, F#, G, and
              G#. Please note that I don't intend to inlude the
              use of flat intervals (ie: Gb) because excentially they can be
              also expressed in terms of the sharp intervals. It is not really
              necessary and including them would mean to make my code longer and
              and perhaps more complicate.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="BassNote" type="NoteType">
          <xs:annotation>
            <xs:documentation xml:lang="en">
              This is the root note for your chord. If not given, then this
              pedal won't send a bass note; this can be used, for example, if
              you want to use this pedal to select the next bank, or you can
              also send another MIDI or a SysEx message.
              
              Please note that if you give a note symbol, then the reference
              octave for this note will be the one defined by the Octave
              attribute; otherwise, it will be calculated from the note number.
              You may transpose it by setting the BassPedalTranspose attribute;
              if you don't define it here, then the one from the parent element
              will be assumed.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ChordNotes" type="NoteSequenceType">
          <xs:annotation>
            <xs:documentation xml:lang="en">
              Here you can enter a comma separated sequence of notes defining
              your chord, ie: C#, F, G#. Please note that the first octave will
              be located in C#, then the other notes will be transposed
              accordingly, so, here the order matters. The first octave will be
              calculated as follows:
              ChordOctave = Octave + ChordTranspose
              
              So, if Octave equals to 3 and ChordTranspose equals to -2, then
              the chord notes will be: C#1, F1, and G#1; however, if you enter
              a different inversion, ie: G#, F, and C#, then the resulting notes
              would be: G#1, F2, and C#3.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="BankSelect" type="BankSelectType">
          <xs:annotation>
            <xs:documentation xml:lang="en">
              Bank number that the controller will select after this pedal has
              been pressed. You can either enter a number between 1 and 119 or
              'Next' (select next bank), 'Previous' (select previous bank),
              'Last' (select the last bank), 'Quit' (quit the controller
              software), 'Reload' (restart the controller; here the whole xml
              config file will be reloaded), 'Reboot' (reboots the computer or
              microcontroller running the software), 'Shutdown' (shutdowns
              the system), or 'List' (sends a SysEx back with the bank names).
              
              Note: there is no symbol for selecting the first bank; for doing
              this just send a '1'.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="SendPanic" type="xs:boolean" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en">
              Whether or not to send the Panic command after pushing this pedal
              (it triggers on NOTE OFF). For this to work, you will need to
              define the "Panic" node.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:simpleType name="NoteType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for notes.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:appinfo>
          This type must be either a value between 0 (C-2) and 127 (G8) or one
          of the following symbols: A, A#, B, C, C#, D, D#, E, F, F#, G, and G#.
        </xs:appinfo>
      </xs:annotation>
      <xs:pattern
        value="A|A#|B|C|C#|D|D#|E|F|F#|G|G#|[0-9]|[1-9][0-9]|1[0-2][0-7]"
      />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="OctaveType">
    <xs:restriction base="xs:integer">
      <xs:annotation>
        <xs:appinfo>
          This attribute must be a value betwen -2 and 8.
        </xs:appinfo>
      </xs:annotation>
      <xs:minInclusive value="-2"/>
      <xs:maxInclusive value="8"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="NoteSequenceType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for a comma separated note list.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:documentation>
          This type is a comma separated list of the following symbols: A, A#,
          B, C, C#, D, D#, E, F, F#, G, and G#, ie, a valid value would be:
          "C#,F,G#". Please note that the minimum length of a chord is one note,
          which corresponds to the fingered mode on a keyboard.
        </xs:documentation>
      </xs:annotation>
      <xs:pattern
        value="((A|A#|B|C|C#|D|D#|E|F|F#|G|G#)(,(A|A#|B|C|C#|D|D#|E|F|F#|G|G#))*)|(([0-9]|[1-9][0-9]|1[0-2][0-7])(,([0-9]|[1-9][0-9]|1[0-2][0-7]))*)"
      />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="BankSelectType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for Bank Select messages
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:documentation>
          This type is a value between 1 and 119 or 'Next' (select next bank),
          'Previous' (select previous bank), 'Last' (select the last bank),
          'Quit' (quit the controller software), 'Reload' (restart the
          controller; here the whole xml config file will be reloaded), 'Reboot'
          (reboots the computer or microcontroller running the software), or
          'Shutdown' (shutdowns the system), or 'List' (gets a list of the bank
          names and their indexes).
        </xs:documentation>
      </xs:annotation>
      <xs:pattern value="Next|Previous|Last|Quit|Reload|Reboot|Shutdown|List|[1-9]|[1-9][0-9]|1[0-1][0-9]"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:group name="MessageGroup">
    <xs:annotation>
      <xs:documentation>
        Groups the different kind of messages and allows to use them in several
        nodes: Start, Stop, and Pedal.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Message" type="MessageType" minOccurs="0"
                  maxOccurs="unbounded">
        <xs:alternative type="MidiMessageType" test="@Type='Midi'">
          <xs:annotation>
            <xs:documentation xml:lang="en">
              Here you can send general MIDI messages, ie: a program change,
              a control change, rhythm start/stop, etc.. Please note that
              MIDI messages can only content pairs of hexadecimal numbers
              separated by one space.
            </xs:documentation>
          </xs:annotation>
        </xs:alternative>
        <xs:alternative type="SysExMessageType" test="@Type='SysEx'">
          <xs:annotation>
            <xs:documentation xml:lang="en">
              Here you can send System Exclusive messages (or SysEx), ie: a
              select a voice panel on your keyboard, change the
              registration, etc.. Please note that SysEx messages must start
              with F0 and end with F7 and they can contain only pairs of
              hexadecimal numbers separated by one space.
            </xs:documentation>
          </xs:annotation>
        </xs:alternative>
      </xs:element>          
    </xs:sequence>
  </xs:group>

  <xs:complexType name="MessageType">
    <xs:annotation>
      <xs:documentation>
        This will restrict message types to Midi or SysEx
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="Type">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:annotation>
            <xs:documentation>
              Only 'Midi' or 'SysEx' is allow for the Type attribute.
            </xs:documentation>
          </xs:annotation>
          <xs:enumeration value="Midi"/>
          <xs:enumeration value="SysEx"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="Trigger" type="MessageTriggerType" default="NoteOn">
      <xs:annotation>
        <xs:documentation xml:lang="en">
          When to trigger an specific message. Possible values: NoteOn and
          NoteOff will trigger the message during a NOTE ON or NOTE OFF message
          respectively. Inside the Start and Stop nodes, where you don't have
          NOTE ON or OFF messages, this attribute won't do anything. It defaults
          to NoteOn.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="MidiMessageType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for defining general MIDI messages.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="MessageType">
        <xs:attribute name="String">
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:annotation>
                <xs:documentation xml:lang="en">
                  It can be only pair of hexadecimal numbers separated by one
                  space. The minimun length would be one pair of hexadecimal
                  numbers and maximum three pairs (three bytes).                  
                  Only this patterns will be allowed:
                  Channel Voice Messages
                  8n 0xxxxxxx 0yyyyyyy = NOTE OFF
                  9n 0xxxxxxx 0yyyyyyy = NOTE ON
                  An 0xxxxxxx 0yyyyyyy = Polyphonic Key Pressure
                  Bn 0xxxxxxx 0yyyyyyy = Control Change
                  Cn 0xxxxxxx          = Program Change
                  Dn 0xxxxxxx          = Channel Pressure
                  En 0xxxxxxx 0yyyyyyy = Pitch Bend Change
                  System Common Messages (SysEx belongs here, but it will be handled separatelly)
                  F1 0xxxxxxx          = MIDI Time Code Quarter Frame
                  F2 0xxxxxxx 0yyyyyyy = Song Position Pointer
                  F3 0xxxxxxx          = Song Select
                  F6                   = Tune Request
                  System Real-Time Messages 
                  F8                   = Timing Clock
                  FA                   = Start
                  FB                   = Continue
                  FC                   = Stop
                  FE                   = Active Sensing
                  FF                   = Reset
                  Where:
                  * n        = MIDI channel from 0 till F
                  * 0xxxxxxx = First data byte going from 00 until 7F
                  * 0yyyyyyy = Second data byte going from 00 until 7F
                  
                  The messages: F4, F5, F9, and FD are undefined (reserved for
                  future use)
                </xs:documentation>
              </xs:annotation>
              <xs:pattern value="(F(6|8|[A-C]|[E-F]))|((((F2|([8-9A-CE][0-9A-F])) ([0-7][0-9A-F]))|((F(1|3))|((C|D)[0-9A-F]))) ([0-7][0-9A-F]))"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="SysExMessageType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Type for defining SysEx messages.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="MessageType">
        <xs:attribute name="String">
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:annotation>
                <xs:documentation xml:lang="en">
                  It must contain pairs of hexadecimal numbers separated by one
                  space, begining with F0 and ending with F7 and each byte in
                  between can only go from 00 until 7F.
                </xs:documentation>
              </xs:annotation>
              <xs:pattern value="F0 ([0-7][0-9A-F] )+F7"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:simpleType name="MessageTriggerType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        When to trigger an specific message. Possible values: NoteOn and
        NoteOff will trigger the message during a NOTE ON or NOTE OFF message
        respectively. Inside the Start and Stop nodes, where you don't have
        NOTE ON or OFF messages, this attribute won't do anything.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:appinfo>
          This attribute must be either NoteOn or NoteOff.
        </xs:appinfo>
      </xs:annotation>
      <xs:pattern value="NoteOn|NoteOff"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="PanicNodeType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
        Here you can either include the text of the panic command or give a path
        to a text file containing it.
        
        The command text can contain the following elements:
        * a comment: //some comment
        * a MIDI message (see the definition of MidiMessageType for a list of
          valid messages)
        * A SysEx message (see the definition of SysExMessageType for seen the
          form of a valid message)
        You may have spaces or tabs at the beginning and end of each line;
        each line will be separated by an enter.
        
        Since this validation is really difficult to do here, I opted to do it
        inside the python code.
      </xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="File" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">
              Path to the file containing the Panic message. It should be a
              text file containing several lines with MIDI messages that
              represent the panic message from your device (ie: an Emagic
              Unitor 8). This file may include comments starting with "//" and
              also empty lines, which will be discarted. Please note that the
              validity of this path will be checked inside the python code.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
</xs:schema>